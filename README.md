# Slac_start
1. Development
The core requirement that development was built around is visibility, adaptability and correctness. All data is retrieved from the sponsor server and has no native static data stored within the application. This means that any server that transmits data in the same pattern can be used to supply data to the application allowing it to be transferable. The application maintains correctness through a indepth syncronization process and updater queue that allows the server to individually handle each change to maintain correctness. Every action that is carried out by a user has a visible feedback and message that will be presented to the user in order to inform them of the status of their action. 
Each feature requested from the sponsor was written up into a full UML use case diagram before software implementation. After this step programmers familiarized themselves with the necessary syntax and Swift documentation necessary to develop each feature.Each feature was developed from the ground up after the necessary top down framework for quick stitching of any new feature was put in place to form the back bone of the the application. The application all operates on a feature called a Navigation View Controller. The Navigation View Controller (from here on refered to as NVC), forms a stack that all subsequent Views and View Controllers are pushed to the top of when they are generated. This means the NVC handles all navigation within the application and means new View Controllers and their Views can be freely attached to the stack. The NVC stack allows for lateral placement of views within the stack as well. Since the navigation stack is a true stack all stack functions can be performed on it: push, pop, search, and pushing a number of Views/View Controllers or popping any number. 
Any new features do not need to directly integrate with any other previous features, they only need to be added to the NVC. This drastically reduced the time for adding new features as the integration code for each View/ View Controller was reduced to a single line of code. Passing data between items on the stack can be handled in any number of ways depending on the use case that data needs to be applied to. Due to the NVC each feature is able to be developed independant of all others speeding up development time. 
The application relies heavily on network access to the server containing the cable data and rci on its initial launch and at syncing but is able to run without network connection after all data has been stored on the device. These features of online mode and offline mode were developed by configuring a network controller device in the application the pings the server in a one second interval and awaits a response. If no response is recieved the application will run in offline mode with the ability to return to online mode at anytime if network connection to the server can be established. The interval window and server location are freely configurable. 
Most of the screens of the application do not allow active manipulation of the cable information as these should always remain static. The screens for this are the Project View, Folder View, and Cable List View. All of these views are generated from data recieved from the server that are stored in jsons and contain no static elements. The folders in particular are generated by creating a dictoinary of the cable groups that creates an incrementing counter for each group after the first instance is found and then provides a sorting metric for all other views. 
Cable List View represents the greatest number of features required by the sponsor, it contains the searching function to select the wanted wire, the ability to manually select a wire and access to a qr scanner that has the ability to read a qr code tag attached to each wire to pull up the wire in question and the upload function. As the app has a folder system, when the folder is selected it will initailly only show the cables in the selected folder but does allow when searching or using the qr scanner to search the entire cable registry regardless of folder. The QR scanner contains a video preview seen from the devices camera with an aiming reticle to ease usage. The reticle will change colors on successful acquisition of a qr code and cause the device to make a sound and vibrate on a success. The QR code will then be decoded and sent to the search function to pull up the requested wire. 
The cable details page represents the View where the Register of Install can be manipulated by the user with a series of toggle switches and the ability for the user to pull up the full information on the cable. The page displays all pertinent information on the cable through uneditable textfields provided by Swift. The app checks to see if any toggles have been changed from the input recieved by the server. If changes are registered these changes are added to the saving system along with date of changes, time of changes and user that made the changes. These changes can be discarded or submitted to the uploader queue with the pressing of a button that will then present a menu of options. If discard is pressed all changes since the last save will be reset and if save pressed all changes will be saved and added to the uploader queue. The uploader queue is represented by an array that stores all items prepped for uploaded and allows the developer (or user if the feature is enabled) to view all items that are ready for upload. 
Returning to the Cable List page to address the uploader function. The uploader function conducts several tests before upload. It initially checks to see if the uploader queue is empty, if emptry it will abort and display error message, if not empty it will proceed. The uploader will then perform a check to make sure the uploaded information can be accurately encoded into a json, if it cannot will abort with message, if it can will proceed. Uploader then performs network connectivity check to make sure server can be reached. If reachable will proceed with sending the endcodes json(s) to the server. Each breakout action of the uploader prints out a message to the user that must be clicked away from to increase transparancy. On recieving message back from server of successful push uploader queue is emptied. 

2. Testing
Each feature that was requested went through rigourous testing and the code is built with many safeguards into each active feature. Test cases were written up for each feature and multiple invalid inputs were sent against all active components. Data types within the application are protected by Swift optional data types that flag incorrect data without allowing that application to expirence catastrophic failure. The json encoder and decoder contains multiple guard cases that create console logs of each operation and print out error statements should a false input arise. 
Most of the testing is around the ability of a user to apply changes to the Register of Install (as this is the only portion of the data that should be manipulated by the user). Test cases were developed for incorrect data being sent by the user and server. The application handles all these cases in multiple ways. On the server side it cleans the data and transfers it into a usable format and on the user side it does not allow the submission of incorrect information by regulating how each user can interact with the data. 



3. Production/Deployment
